# 추석 트래픽 : [문제링크](https://programmers.co.kr/learn/courses/30/lessons/17676)

## 문제 난이도 : 카카오 level 3 이나 level 2보다 조금 어려운듯

## 문제이해 :

- 입력으로 주어진 시간 (년 월 일 : hh:mm:ss.sss(밀리초))과 주어진시간의 처리시간 (2.0s)을 통하여 입력으로 주어진 시간 들을 통해서 1초동안 최대로 처리할수있는 최대처리량을 구하면된다 (어느 한 구간에서 최대로 처리할수있는량)

## 문제해결방법 :

- 입력으로 주어진 시간 hh:mm:ss.sss를 밀리초로 바꾼다
- 밀리초로 바꾸면 주어진 시간의 끝나는지점(end_time)된다
- end_time을 구했으면 처리시간을 통해 start_time을 구할수있다.

  - 이떄 start_time은 2016-09-15 03:10:33.020 0.011s 일경우 03:10:33.010초부터 03:10:33.020초에 해당된다
  - start_time = end_time -처리시간 이고
  - 이때 처리시간은 시작시간과 끝시간을 포함하므로 start_time에 +1(1밀리) 을 더해준다

- 해당구간의 start_time과 end_time을 구했으면 start_time~end_time+999 까지를 해당 구간으로 볼수있다
  - 이를 통해 times라는 배열에 ["start",start_time] 과 ["end,end_time+999]를 넣어준다
  - times 라는 배열에 값이 저장이되면 정렬을 통해 시간을 오름차순으로 정렬을 시킨다
  - 오름차순으로 정렬을 시키면 시간이 작은순서대로 저장이되고 end가 나올떄까지 카운팅을 하고 end가나오면 더이상 그 구간이아니므로 카운팅을 줄이는과정을반복해서 가장 큰 최대처리량을 구할수있다.

## 문제를 풀며 느낀점 :

- 문제를 이해를 못해서 해결을 못한거같다. 문제를 이해하자마자 바로 어떤식으로 풀지는 생각이 났다. 그러나 여전히 문제이해도가 너무딸리다
- 알고리즘 적으로는 시간복잡도 n^2까지 허용이 되서 이중반복문으로도 답을 구할수 있어 알고리즘적인 문제로는 전혀 어려운게 아니다
- 알고리즘 자체가 아무리 쉬워도 문제를 이해못하면 도루묵이다..

## 소스코드

```js
// https://velog.io/@longroadhome/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-LV.3-%EC%B6%94%EC%84%9D-%ED%8A%B8%EB%9E%98%ED%94%BD-JS 참조

function solution(lines) {
  const times = [];

  answer = 0;
  // 1. 주어진 구간 을 초로 변환 시킴
  for (const line of lines) {
    let [days, time, duration] = line.split(" ");
    // 밀단위
    let endtime = getSecondtoMill(time);

    let start_time = getStartTimetoMill(duration, endtime) + 1;
    //  마지막 구간에 +999를 해서 초당 처리량에 해당되는 범위를 전부 잡을수있음
    endtime += 999;

    times.push(["Start", start_time]);
    times.push(["End", endtime]);
  }

  times.sort(sorting);
  cnt = 0;
  for (let i = 0; i < times.length; i++) {
    if (times[i][0] == "Start") {
      cnt += 1;
    } else {
      cnt -= 1;
    }
    answer = Math.max(cnt, answer);
  }
  return answer;
}

const getSecondtoMill = (time) => {
  let hours = +(time[0] + time[1]) * 3600;
  let minute = +(time[3] + time[4]) * 60;
  let second = +(time[6] + time[7]);
  let mills = +(time[9] + time[10] + time[11]);
  return (hours + minute + second) * 1000 + mills;
};
const getStartTimetoMill = (duration, time) => {
  // 밀리초 단위로
  let number = duration.substr(0, duration.length - 1) * 1000;
  return time - number;
};

const sorting = (a, b) => {
  if (a[1] == b[1]) {
    return -1;
  } else {
    return a[1] - b[1];
  }
};

//   solution([
//     "2016-09-15 01:00:04.002 2.0s",
//     "2016-09-15 01:00:07.000 2s"
//     ])

// solution([
//     "2016-09-15 01:00:04.001 2.0s",
//     "2016-09-15 01:00:07.000 2s"
//     ]
```
