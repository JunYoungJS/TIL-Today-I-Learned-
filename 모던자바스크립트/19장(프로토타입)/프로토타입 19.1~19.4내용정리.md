- 자바스크립트는 프로토타입 기반의 객체지향프로그래밍 언어이다

  - 프로토타입 기반으로 상속을 구현하여 불필요한 중복을 제거한다

- 객체지향 프로그래밍 언어란 ?
  - 실세계의 사물을 기반으로 프로그래밍을 접목시킴

> 객체지향 프로그래밍 예시

```js
const circle ={
    radius:5,

    getDiameter(){
        return 2 * this.radius;
    }
    getArea(){
        return Math.PI *this.radius **2;
    }
}
```

- 객체는 상태 데이터와 동작으로 묶은 복합적인 자료구조 (프로퍼티 =상태 (radius) , 메소드 = 동작 (getArea,getDiameter))

> 상속을 통해 불필요한 중복을 제거

```js
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    return Math.PI * this.radius ** 2;
  };
}
// 이러한 생성자함수는 인스턴스를 생성할떄마다 중복된 메소드를 생성하여 메모리 낭비가 심해짐

// 개선 방법
function Circle(radius) {
  this.radius = radius;
}
// 프로토타입을 통해서 상속을 구현 => 인스턴스 생성시 중복된 메소드가 매번 생기지 않음
// Circle.prototype에 하나만 할당됨
Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};
```

# 프로토타입 객체

- 객체간 상속을 구현하기 위해 사용
- 프로토타입을 통해 객체의 상위 부모의 메소드와 공유 프로퍼티를 제공받고 자식은 자유롭게사용이가능

  - 모든객체는 [[Prototype]] 이라는 내부슬롯을 가지며 내부슬롯을 통해 부모의 prototype에 접근하나 내부슬롯이 아닌 실제론 **proto**로 접근을할수있음

- **proto**를 통해 프로토타입에 접근하고 해당 프로토타입의 constructor를 통해 생성자함수에 접근할수있다.
- 모든객체는 **proto**를 통해 프로퍼티를 접근한다 ([[Prototype]] 으로 직접 접근 x)
  - 프로토타입 체인에의해 해당 객체에 접근하려는 프로퍼티가 없으면 **proto**로 상위객체에 올라가서 탐색하는식
- **proto**는 object.prototype의 프로퍼티
- **proto**로 접근하거나 값을 할당시 암묵적으로 getter함수와 setter함수가 호출됨
- **proto** 접근자 프로퍼티를 사용하지않는것이 좋음 (모든객체가 접근자프로티를 사용할수있는게 아님)
  - getPrototypeOf 메소드나 setPrototypeof메소드를 사용하는것을 권장

# prototype 프로퍼티를 가지고있지않은것

- 화살표함수 , es6 메소드 축약표현

# 프로토타입 constructor 프로퍼티와 생성자 함수

- 모든 프로토타입은 constructor 프로퍼티를 가진다.
  - 인스턴스는 **proto**를 통해서 constructor 속성을 찾고 이 속성은 생성자 함수와 연결되어있음

# 리터럴표기법으로 생성된 객체 와 new를 통해 생성한 객체의 차이

- 둘다 프로토타입을 가지고 내부적으로 추상연산을 호출하여 프로토타입을 갖는 빈객체를 생성 (동일 )
- new target (new 키워드로 생성했는지 확인하는 프로퍼티) 의 확인이나 프로퍼티를 추가하는 처리등 세부내용은 다름
